//
//  latest finding : remote-outbound-rtp in getStats() may provide remote timestamp in DOM time
//  w3c description : remoteTimestamp [Optional]
//      A DOMHighResTimeStamp specifying the timestamp (on the remote device) 
//      at which the statistics in the RTCRemoteOutboundRtpStreamStats object were sent by the remote endpoint.
//      it represents the time at which the object's statistics were received or generated by the local endpoint.
//      The RTCRemoteOutboundRtpStreamStats object's remoteTimestamp property 
//      provides statistics based on the received data's NTP timestamp taken from an RTCP Sender Report (SR) block. 
//      Be aware that the remote clock may not be synchronized with the local clock(either in current time or speed at which time elapses).
//

var standard_dom_time = null;
var remote_ntp_time = null;
var attempt = null;

var send_sync_time = null;
var sync_interval = 1000

function sendSync() { 
    if (!dc) {
        console.error("sendSync should not be called when datachannel hasn't been initialized!")
        return 
    }
    attempt = setInterval(checkReadyAndSend, sync_interval)
}   

function checkReadyAndSend() {
    //console.log(dc.readyState)
    if (dc.readyState === 'open') { 
        //console.log("<<<<<< send sync")
        var t = "&" + performance.now()
        //console.log("<<< time to be send : "+t)
        dc.send(t)
        send_sync_time = performance.now()
    } 
}

//
//  Now disable periodic clock sync , syncing remote NTP and local DOM time only once
//  Noted that if bug 3-20 still exists, there is a chance that all following syncing attempts will fail
//  even checkReadyAndSend is called periodicly
//
function handleSyncReply(data) {
    let recv_sync_time = performance.now()
    var arr = data.split('&')
    if (arr.length != 3) {
        console.error("sync has encountered unexpected reply : " + data)
        return
    }
    //arr[1] is currently unused
    standard_dom_time = send_sync_time + (recv_sync_time - send_sync_time) / 2
    console.log("estimated rtt : " + (recv_sync_time - send_sync_time))
    remote_ntp_time = arr[2]
    sync_ready = true
    console.log("&& dom time : " + standard_dom_time + " && ntp_time : " + remote_ntp_time)
    if (attempt && sync_interval == 1000) {
        clearInterval(attempt)
        sync_interval = 60000
        attempt = setInterval(checkReadyAndSend, sync_interval)
    } 
}

function calDelay(present_time, rtp_time) {
    let remote_gap = (rtp_time - (90 * remote_ntp_time)%(2**32) - 1) / 90
    let local_gap = present_time - standard_dom_time
    //console.log("local gap : " + local_gap)
    //console.log("remote gap : " + remote_gap)
    return local_gap - remote_gap
}

//rtp = ntp2*90 + 1
//ntp1
//rtp_base = ntp1*90 + 1